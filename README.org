#+TITLE: DTL model checking algorithms
#+AUTHOR: Augusto Peres

* Introduction

* Features

* Details on the implementation

** Testing and benchmarking 

*** Benchmarking
    To write proper benchmarks visit [[http://taylor.fausak.me/2014/03/04/haskeleton-a-haskell-project-skeleton/#setup][This website]].

** Automata theoretic approach

*** Optimizations that I might need to do

    The first benchmark obtained without any optimizations was the following
    #+BEGIN_SRC shell
    Benchmark dtl-model-checking-benchmark: RUNNING...
    benchmarking Tests for one agent easy:/Benchmarking @_1 [X p] and transition system oneAgent1
    time                 558.1 μs   (551.3 μs .. 566.3 μs)
                        0.998 R²   (0.997 R² .. 0.999 R²)
    mean                 562.5 μs   (557.5 μs .. 574.7 μs)
    std dev              27.12 μs   (12.06 μs .. 52.55 μs)
    variance introduced by outliers: 41% (moderately inflated)

    benchmarking Tests for one agent easy:/Benchamarking @_1 [X p => ~p] and transtion system oneAgent
    time                 241.3 μs   (224.3 μs .. 256.7 μs)
                        0.979 R²   (0.975 R² .. 0.988 R²)
    mean                 221.6 μs   (216.0 μs .. 230.1 μs)
    std dev              21.51 μs   (16.32 μs .. 26.74 μs)
    variance introduced by outliers: 77% (severely inflated)

    benchmarking Tests for two agents easy:/Testing for @_1[X p], and the DTS in the thesis part of SAT
    time                 1.372 s    (-6.598 s .. 8.464 s)
                        0.197 R²   (0.004 R² .. 1.000 R²)
    mean                 1.201 s    (485.7 ms .. 2.482 s)
    std dev              1.244 s    (88.94 ms .. 1.564 s)
    variance introduced by outliers: 75% (severely inflated)

    benchmarking Tests for two agents easy:/Testing for @_1[c_2[~q]], and the transition system tThesis
    time                 121.2 ms   (111.6 ms .. 131.0 ms)
                        0.995 R²   (0.987 R² .. 0.999 R²)
    mean                 129.0 ms   (126.1 ms .. 132.5 ms)
    std dev              5.296 ms   (3.392 ms .. 8.048 ms)
    variance introduced by outliers: 11% (moderately inflated)

    benchmarking Tests for two agents easy:/Testing for @_1[p] => @_2[F q] and for transition system in thesis
    time                 1.015 s    (807.3 ms .. 1.113 s)
                        0.995 R²   (0.987 R² .. 1.000 R²)
    mean                 1.038 s    (1.009 s .. 1.064 s)
    std dev              31.53 ms   (22.10 ms .. 38.45 ms)
    variance introduced by outliers: 19% (moderately inflated)

    benchmarking Tests for two agents easy:/Testing for @_1[p] => @_2[X(X q)] and for transition system tThesis
    time                 661.0 ms   (577.1 ms .. 747.9 ms)
                        0.998 R²   (0.992 R² .. 1.000 R²)
    mean                 638.0 ms   (621.7 ms .. 655.1 ms)
    std dev              21.00 ms   (9.602 ms .. 26.64 ms)
    variance introduced by outliers: 19% (moderately inflated)

    benchmarking Tests for two agents medium:/Testing for alphaBenchmarkMedium1 and tThesis
    Benchmark dtl-model-checking-benchmark: ERROR

    --  While building package dtl-model-checking-0.1.0.0 using:
        /Users/augusto/.stack/setup-exe-cache/x86_64-osx/Cabal-simple_mPHDZzAJ_2.4.0.1_ghc-8.6.5 --builddir=.stack-work/dist/x86_64-osx/Cabal-2.4.0.1 bench dtl-model-checking-benchmark
      Process exited with code: ExitFailure 1
    #+END_SRC

**** Make automatons smaller [2/4]
     - [X] Make the states as in the solution proposal.
     - [X] Change the function ~dorProduct~.
     - [ ] Remove the propositional symbols input from the automatons
       We need only the propositional symbols present in the formula therefore
       it is stupid to use pass all the propositional symbols to the automaton.
     - [ ] Do the same for the function that gives the counter examples.

     Do this using the new definition. To see what the new definition is just
     refer to question in the email to Jaime using the definition of /maximal/ set.
     
     This optimization seems essential as the benchmarks did not even finish
     running. It got stuck in transition systems with 16 states, which is still
     very small despite the fact that I left the program running for 6 hours.

     This were the benchmarks before the optimization.

     #+BEGIN_SRC shell
     dtl-model-checking> benchmarks
     Running 1 benchmarks...
     Benchmark dtl-model-checking-benchmark: RUNNING...
     benchmarking for one agent easy:/Benchmarking @_1 [X p] and transition system oneAgent1
     time                 660.8 μs   (621.1 μs .. 701.3 μs)
                         0.930 R²   (0.856 R² .. 0.977 R²)
     mean                 833.5 μs   (737.2 μs .. 1.027 ms)
     std dev              453.8 μs   (291.2 μs .. 719.8 μs)
     variance introduced by outliers: 99% (severely inflated)

     benchmarking for one agent easy:/Benchamarking @_1 [X p => ~p] and transtion system oneAgent
     time                 226.1 μs   (220.0 μs .. 232.4 μs)
                         0.977 R²   (0.953 R² .. 0.991 R²)
     mean                 254.7 μs   (240.0 μs .. 290.5 μs)
     std dev              81.81 μs   (34.78 μs .. 141.3 μs)
     variance introduced by outliers: 98% (severely inflated)

     benchmarking for two agents easy:/Testing for @_1[X p], and the DTS in the thesis part of SAT
     time                 182.8 ms   (169.2 ms .. 192.8 ms)
                         0.997 R²   (0.989 R² .. 1.000 R²)
     mean                 188.0 ms   (183.7 ms .. 195.1 ms)
     std dev              7.857 ms   (2.107 ms .. 11.06 ms)
     variance introduced by outliers: 14% (moderately inflated)

     benchmarking for two agents easy:/Testing for @_1[c_2[~q]], and the transition system tThesis
     time                 128.9 ms   (122.5 ms .. 146.3 ms)
                         0.987 R²   (0.951 R² .. 1.000 R²)
     mean                 133.3 ms   (129.4 ms .. 140.0 ms)
     std dev              7.297 ms   (5.473 ms .. 9.728 ms)
     variance introduced by outliers: 11% (moderately inflated)

     benchmarking for two agents easy:/Testing for @_1[p] => @_2[F q] and for transition system in thesis
     time                 1.184 s    (1.089 s .. 1.346 s)
                         0.997 R²   (0.996 R² .. 1.000 R²)
     mean                 1.106 s    (1.081 s .. 1.147 s)
     std dev              38.26 ms   (3.020 ms .. 48.07 ms)
     variance introduced by outliers: 19% (moderately inflated)

     benchmarking for two agents easy:/Testing for @_1[p] => @_2[X(X q)] and for transition system tThesis
     time                 670.9 ms   (601.9 ms .. NaN s)
                         0.998 R²   (0.994 R² .. 1.000 R²)
     mean                 680.8 ms   (666.4 ms .. 693.5 ms)
     std dev              15.29 ms   (13.27 ms .. 17.09 ms)
     variance introduced by outliers: 19% (moderately inflated)

     benchmarking 8 states and easy formulas:/Testing for transition system t8StatesAgents1 and fEasy1
     time                 20.78 s    (15.80 s .. 26.97 s)
                         0.990 R²   (0.967 R² .. 1.000 R²)
     mean                 18.26 s    (16.62 s .. 19.50 s)
     std dev              1.811 s    (1.093 s .. 2.213 s)
     variance introduced by outliers: 23% (moderately inflated)

     benchmarking 8 states and easy formulas:/Testing for transition system t8StatesAgents2 and fEasy1
     time                 15.05 s    (14.51 s .. 15.54 s)
                         1.000 R²   (1.000 R² .. 1.000 R²)
     mean                 15.14 s    (15.03 s .. 15.27 s)
     std dev              128.5 ms   (101.2 ms .. 149.0 ms)
     variance introduced by outliers: 19% (moderately inflated)

     benchmarking 8 states and easy formulas:/Testing for transition system t8StatesAgents3 and fEasy1
     time                 14.81 s    (NaN s .. 15.51 s)
                         1.000 R²   (0.999 R² .. 1.000 R²)
     mean                 15.02 s    (14.93 s .. 15.18 s)
     std dev              156.6 ms   (46.09 ms .. 209.4 ms)
     variance introduced by outliers: 19% (moderately inflated)

     benchmarking 8 states and easy formulas:/Testing for transition system t8StatesAgents4 and fEasy1
     time                 14.96 s    (14.40 s .. NaN s)
                         1.000 R²   (NaN R² .. 1.000 R²)
     mean                 15.00 s    (14.94 s .. 15.07 s)
     std dev              83.76 ms   (43.23 ms .. 102.0 ms)
     variance introduced by outliers: 19% (moderately inflated)

     benchmarking 8 states and easy formulas:/Testing for transition system t8StatesAgents1 and fEasy2
     time                 5.225 s    (4.983 s .. 5.547 s)
                         0.999 R²   (0.999 R² .. 1.000 R²)
     mean                 5.520 s    (5.373 s .. 5.759 s)
     std dev              253.1 ms   (23.96 ms .. 316.2 ms)
     variance introduced by outliers: 19% (moderately inflated)

     benchmarking 8 states and easy formulas:/Testing for transition system t8StatesAgents2 and fEasy2
     time                 5.399 s    (5.318 s .. 5.533 s)
                         1.000 R²   (1.000 R² .. 1.000 R²)
     mean                 5.379 s    (5.312 s .. 5.401 s)
     std dev              47.77 ms   (10.67 ms .. 63.68 ms)
     variance introduced by outliers: 19% (moderately inflated)

     benchmarking 8 states and easy formulas:/Testing for transition system t8StatesAgents3 and fEasy2
     time                 5.304 s    (5.080 s .. 5.498 s)
                         1.000 R²   (1.000 R² .. 1.000 R²)
     mean                 5.483 s    (5.412 s .. 5.596 s)
     std dev              112.1 ms   (44.12 ms .. 154.2 ms)
     variance introduced by outliers: 19% (moderately inflated)

     benchmarking 8 states and easy formulas:/Testing for transition system t8StatesAgents4 and fEasy2
     time                 5.473 s    (5.252 s .. 5.601 s)
                         1.000 R²   (0.999 R² .. 1.000 R²)
     mean                 5.427 s    (5.355 s .. 5.453 s)
     std dev              49.07 ms   (806.3 μs .. 59.95 ms)
     variance introduced by outliers: 19% (moderately inflated)

     benchmarking 16 states and easy formulas:/Testing for transition system t16StatesAgents1 and fEasy1
     ^C
     #+END_SRC

     This must be fixed as my goal is to be able to model check with state space
     over 1000 states.

     This should be an easy enough fix.
     
     1. Change the states of the automaton in order to allow just propositional
        symbols that appear in the closure of the formula.
     2. Change the ~dotProduct~ function to allow for transitions when the label
        of the state is contains the Set responsible for the transition in the automaton. 
     
**** TODO In the function ~downArrow~ see the optimization note 

**** TODO When converting GNBA -> NBA.
   I believe this function would be much more efficient if I make a direction
   construction of the transition function.
   See the note in the comment of ~convertGNBAToNBA~ in the aoutomata theoretic module.

**** TODO The same as the previous point but for the ~dotProduct~. 
     It should be much more efficient if I make the construction of the
     transition relation directly instead of filtering for all of the states in
     the automaton and then adding to the system. 

**** TODO Reducing the automatons and the transition system.
     I should see what is the effect of reducing the transitions system and the
     automatons before and computing strongly connected components.
     The reduction of the automatons should include reducing the GNBA based on
     the final sets.

**** Efficiency of visited is reachable
     In the modules ~DTS.hs~ and ~NBA.hs~ when using the functions is reachable
     i use dfs. This makes a traversal over all the transitions system. This
     could be improved to stop when the arrival node is found.

*** Things that could use improvement.

**** DONE The model Checking answer
     CLOSED: [2020-04-22 Wed 00:29]
     I should create a data type for the model checking answer, that way I can
     provide counter example. For example:

     #+BEGIN_SRC haskell
     data ModelCheckingResult a = Satisfies
                                | CounterExample a
                                deriving (Show, Eq, Ord)
     #+END_SRC

     This way I can provide an answer with a counter example in the cases where
     it is not verified

** BDD model checking 

** Bounded model checking

* Next steps

** KNOWCAUSE Cannot create Maps with ROBDDs 
   This is because the instance for order (in the case of the leafs) is not
   properly done and could use improvement. Not a major concern as I can simply
   use the labels which usually also derive order 

** FIXED fails for @_1[c_2(~q)] in the transition system were it should not fail. 
   CLOSED: [2020-04-14 Tue 17:30]
   Never mind. The formula should still fail

** FIXED the algorithm is returning always True.
   CLOSED: [2020-04-14 Tue 17:21]
   The automatons seem to be in working order. The problem must be, therefore on
   the ~dotProduct~ function or when passing to NBA.

   This is caused by the fact that the product does not yield a deterministic
   automaton. The only solution is to change the module ~DTS.hs~ to allow for
   non deterministic transition systems in regards to the transition function.

   There was also a bug that was solved. The was the labels of the transitions
   system would not cause transitions in the automatons using the definition
   with $\sigma = q \cap Lit_i$.

   Instead I should use the condition
   $$\sigma = q \cap AP_i$$
   Then I must change the definition of alphabet to consist only of valuations.

   The previous correction fixed 3 of the 4 test instances

   It still fails for more than one agent

   <2020-04-14 Tue> Found one mistake. I also needed to check that the states in
   strongly connected components were in fact in a loop. Failure to verify this
   causes problems for components with one or more states. 

   <2020-04-14 Tue> Found mistake. In the rules of the global transition
   function I was forcing $\sigma = q \cap AP_i$ instead of $\sigma \cap AP_i =
   q \cap AP_i$

   <2020-04-14 Tue> Found mistake. On is reachable we need to start the dfs at
   false. This eliminates states that don't have self loops.

   <2020-04-14 Tue> Found Mistake. In my thesis. When it is not an action of
   agent we can only require the local formulas to remain unchanged. After that
   there can be changes to the global formulas even if the agent has not taken
   any action.

   <2020-04-14 Tue> Found Mistake. In my thesis(the part with the persistence).
   Must change the definition on the report. Already change in code.

   <2020-04-14 Tue> Found mistake. Could not add some of the transitions to the
   dot product because I was using the function ~T.addTransitionSafe~. Changed
   to ~addTransition~


** DONE Make the model checking algorithm at the top level
   CLOSED: [2020-04-13 Mon 18:57]
   This is, just complete the function using with kosaraju,
 
** DONE Put the function to convert between NBAs and GNBAs in the AutomataTheoreticApproach module [2/2]
   CLOSED: [2020-04-14 Tue 20:57]
   - [X] Make the function from scratch
   - [X] Test the function
     Seems to be working for the small examples tested.

** DONE Make the complementary automaton using my algorithm [4/4]
   CLOSED: [2020-04-10 Fri 15:09]
   - [X] Make the states
   - [X] Make the initial states
   - [X] Make the transition function [3/3]
     - [X] Create a function to test if a transition is possible from a state to
       another state according to a propositional symbol.
     - [X] Create a list with all pairs of states, /i.e/, [(s, s'), ... (w, w')]
     - [X] For each of those pairs of states test the transitions under the
       correct propositional  symbols, /i.e/, the symbols present at those
       states. If said transition is possible then add it to the automaton using
       a fold.
   - [X] Make the accepting sets

** TODO Document the boolean formulas package

** DONE Transition systems module first steps [3/3]
   CLOSED: [2020-04-20 Mon 18:23]
   - [X] Instance graphviz to be able to see the transition systems
     Not really that important and difficult to do because of the constructors
     I can ignore the constructors and just use show on everything. Then, in the
     module, ModelCheckingAppraoch.hs I instance the show properly for all the
     types used.
     ([[file+sys:~/Documents/universidade/MMA/tese-talvez/DTL-Model-Checking/dtl-model-checking/src/DTS.hs][file-here)]]
   - [X] Make manipulation function for states and transitions [2/2]
     - [X] Adding states
     - [X] Adding transitions
   - [X] Function for strongly connected components. This is fundamental for the
     persistence property verification.
     NOTE: This will be pretty much the same
     as the functions for the NBA module. Maybe I can instance a class for both
     of them.
     checking
**** FIXED When using kosaraju
     CLOSED: [2020-04-05 Sun 20:27]
     Does not work property for the transition system ~s = [1, 2, 3, 4]~ with
     transition relation ~3 -a-> 4~ ~4 -a-> 1~.
     NOTE: This probably also implies that there is a BUG in the module for the NBA 

     This is caused by a bad implementation of the algorithm.
     Possible fix: +instead of dfs, I should use the visit subroutine presented in+
     +Wikipedia. Challenging because there is no state in haskell.+     

     This was not necessary, I just needed to change the function ~makeOrder~ to
     prepend /i.e/, ~makeOrder dfs ++ order~. Tested on all the automaton test
     instances and it worked

** TODO Making a function that generates random DTS to be used in model
   NOTE: That this function should preserve all the rules for the transition
   relation. Also note that, in our implementation, we are assuming that the
   transition relation is deterministic. Caution when implementing this in a
   random way.


** DONE The algorithm Exists for binary decision diagrams 
   CLOSED: [2020-04-03 Fri 11:36] DEADLINE: <2020-04-03 Fri>
   
** DONE Start working on the implementation of distributed transition systems
   CLOSED: [2020-04-03 Fri 12:03]

** DONE Make the PRIME functions work for something  other than strings. 
   CLOSED: [2020-04-06 Mon 21:22]
   I do not really need this in the ROBDD.hs module. I can implement the
   functions like image, prime... In the module responsible for the symbolic
   model checking problem.

** DONE Adding transitions in a safe way. 
   CLOSED: [2020-04-05 Sun 16:55]
   Just create checks to see if the transition is possible. Then create
   function like ~addTransitionSafe~.

* Things I am not totally happy about 


** In the algorithm restrict
   I should have the option to return a bdd with something else other than ~Int~
   type.
   Possible fix. I could always change the labels of the binary decision
   diagrams to always be ~Int~. This would prevent me from having all that work
   with orders.

** When using ~Data.Set~ I have to jump back and forth using ~fromList~ and ~toList~
   Maybe I should change the implementation of the distributed transition
   systems to work over lists instead. This would even make it more similar to
   the implementation of the automatons.

